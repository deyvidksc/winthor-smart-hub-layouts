name: CI/CD - Criar Tag de Release

on:
  pull_request:
    types:
      - closed
    branches:
      - main
      - develop

permissions:
  contents: write  # Permite ao GITHUB_TOKEN fazer push para o repositório

jobs:
  release-on-push:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}  # Use o token correto aqui
    steps:
      - name: Checkout do código
        uses: actions/checkout@v3

      - name: Ler versão atual
        id: read_version
        run: |
          VERSION_FILE="version.txt"
          if [[ -f "$VERSION_FILE" ]]; then
            VERSION=$(cat $VERSION_FILE)
          else
            VERSION="1.0.0.0"  # Caso o arquivo de versão não exista, começar com a versão inicial
          fi
          echo "VERSAO_ATUAL=$VERSION" >> $GITHUB_ENV

      - name: Incrementar versão
        id: increment_version
        run: |
          VERSION=${{ env.VERSAO_ATUAL }}
          BRANCH_NAME=${GITHUB_REF#refs/heads/}

          # Extrair os 4 componentes da versão
          IFS='.' read -r -a version_parts <<< "$VERSION"
          
          # Se a versão tem 4 componentes (major.minor.patch.build), processa
          if [ ${#version_parts[@]} -eq 4 ]; then
            major=${version_parts[0]}
            minor=${version_parts[1]}
            patch=${version_parts[2]}
            build=${version_parts[3]}
          else
            echo "A versão não está no formato esperado (major.minor.patch.build)."
            exit 1
          fi

          # Incrementa com base na branch
          if [[ "$BRANCH_NAME" == "main" ]]; then
            # Para main, incrementa o build
            build=$((build + 1))
          elif [[ "$BRANCH_NAME" == "develop" ]]; then
            # Para develop, incrementa o patch e o build é resetado para 1
            patch=$((patch + 1))
            build=1
          else
            echo "Branch não reconhecida para incremento de versão."
            exit 1
          fi

          # Cria a nova versão
          NEW_VERSION="${major}.${minor}.${patch}.${build}"
          echo "Nova versão: $NEW_VERSION"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV

      - name: Atualizar o arquivo de versão
        run: |
          echo ${{ env.NEW_VERSION }} > version.txt
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add version.txt
          git commit -m "Atualizando versão para ${{ env.NEW_VERSION }}"
          git push origin ${{ github.ref }} 

      - name: Criar Tag com a versão
        run: |
          # Criar uma tag usando a versão gerada
          git tag "v${{ env.NEW_VERSION }}"
          git push origin "v${{ env.NEW_VERSION }}" --force

      - name: Gerar Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          use_github_release_notes: true
          tag_name: ${{ env.NEW_VERSION }}
          release_name: Release ${{ env.NEW_VERSION }}
          draft: false
          prerelease: false

     # - name: Gerar Release
     #   uses: rymndhng/release-on-push-action@master
     #   with:
     #     use_github_release_notes: true
     #     tag_prefix: ""  
     #     release_name: ${{ env.NEW_VERSION }}


      - name: Carregar a versão atual
        run: |
          # A versão será passada como variável de ambiente do workflow anterior
          echo "NEW_VERSION=${{ github.event.workflow_run.outputs.NEW_VERSION }}" >> $GITHUB_ENV

      - name: Buscar arquivos modificados
        id: modified_files
        run: |
          # Identifica os arquivos modificados na PR entre o último commit e a base da PR
          git diff --name-only ${{ github.event.workflow_run.head_sha }} ${{ github.sha }} > changed_files.txt
          cat changed_files.txt

      - name: Atualizar version.json nas pastas modificadas
        run: |
          # A versão obtida do workflow anterior será utilizada para atualizar o version.json
          NEW_VERSION="${{ env.NEW_VERSION }}"
          MODIFIED_FOLDERS=$(grep -oP '^[^/]+(?=/)' changed_files.txt | sort -u)

          for folder in $MODIFIED_FOLDERS; do
            # Ignorar as pastas não desejadas
            if [[ "$folder" == ".github" || "$folder" == "version-control" ]]; then
              continue
            fi

            # Verifica se existe um arquivo version.json dentro da pasta
            VERSION_JSON_PATH="$folder/version.json"
            if [[ -f "$VERSION_JSON_PATH" ]]; then
              echo "Atualizando $VERSION_JSON_PATH"
              # Atualiza a versão dentro do version.json
              jq ".versao = \"$NEW_VERSION\"" $VERSION_JSON_PATH > temp_version.json && mv temp_version.json $VERSION_JSON_PATH
              git add $VERSION_JSON_PATH
            fi
          done

      - name: Commit e Push das alterações no version.json
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Verifica se há alterações para commitar
          git diff --exit-code || git commit -m "Atualizando version.json para versão ${{ env.NEW_VERSION }}"
          
          # Push se houver alterações
          git push origin ${{ github.ref }} || echo "Nenhuma alteração para push"

